## 第六章　メソッドとカプセル化の操作

1. ○　
    #### ■ point  
    戻り地について
    - メソッド宣言で戻り値型の宣言は必須.

2. ○ 
3. ○  
4. ○
5. ☓
    ```java
    //可変長引数をもつメソッドは、引数を２つでも、３つでも理論上はいくつでも渡すことができる
    //
    void sample(int...num){}//「...」は引数の型の　直後に記述

    //渡された複数の引数は、JVMによって配列に置き換えられる。そのため、、可変長引数の値を使うときは配列と同じように大かっこを使う

    void sample(int... num){
      for(int i = 0; i < num.length; i++>){
        system.out.println(num[i])
      }
    }

    void sample(int...num){}//「...」は引数の型の　直後に記述
    
    public static void main(String ...args)//メインメソッドでも使用可能
    ```
6. ○
7. ○　*staticなフィールドは、「クラス名.フィールド名」、もしくはインスタンスの生成後であれば「変数名.フィールド名」のどちらでもアクセスができる。*
8. ○ *staticなメソッドは、staticで修飾されたものにしかアクセス出来ない。*
    #### ■ 解説
    >staticなメンバは、インスタンスが作られるメモリの領域（ヒープ領域）とは異なる領域(static領域)に配置される  
    >staticなメンバとその他の定義は、クラスのロード後すぐに行われる。  
    >そのため、staticなメンバはインスタンスの有無に関わらず使える。一方staticでないメンバはインスタンスがないと使えない。  
    >このようなルールが有るため、インスタンスがなくても使えるstaticなメソッドからstaticではないメンバにはアクセスできない。  
    >反対に、staticでなはいメンバから、staticなメンバにアクセスすることは可能。  
    >もし、staticなメソッドから、staticではないフィールドやメソッドにアクセスしようとすると、存在しないものを呼び出すことになるため、コンパイルエラーが発生する。  
    
9. ○  *オーバーロード*  
    #### ■ 解説
    >オーバーロードとは「メソッドの多重定義」とも呼ばれ同名のメソッドを複数宣言できる機能のこと。
    >ただし、名前が同じでも引数が異なるという条件がつく。引数が異なるとは、引数の型や順番が異なることで
    >これらが異なれば同名のメソッドを複数宣言できる。
    >JVMはメソッド名と引数のセットで見分けている。このセットのことを「シグニチャ」とよぶ。
    >変数名、戻り値が異なっていてもオーバーロードとは言えない。
    >戻り値が異なる同名のメソッドがある場合、同名のメソッドがあるとコンパイルエラーが発生する  

10. ○　*曖昧なメソッド呼び出し。*
11. ○　*オーバーロードの条件はシグニチャが異なることで,この条件にアクセス修飾子は含まれない*
12. ○　*コンストラクタのアクセス修飾子に制限はない*
    #### ■ point
12. ○　*コンストラクタのアクセス修飾子に制限はない*
    - コンストラクタのアクセス修飾子に制限はない
    - メソッド名をクラス名と同じにすること
    - 戻り値型は記述できない
    - newと一緒にしか使えない

13. ○　コンストラクタには戻り値は定義できない。戻り値を定義すると、それはコンストラクタではなくメソッドとして扱われる。
    ただし、クラス名と同名のメソッドを定義してはいけないというルールはないため、コンパイルエラーにはならない。

14. ☓　コンストラクタと初期化ブロック
    ```java
    public class Sample(){
      Sample(){
        System.out.println("A");
      }
      //初期化ブロックはコンストラクタの前に記述しても問題ない。
      {
        System.out.println("B");
      }
    }

    public class Main{
      public static void main(String[]args){}
      new Sample();
    }

    実行結果：
    B
    A

    ```
    #### ■ point　
    -　初期化ブロックは、全てのコンストラクタで共通する前処理を記述するために使用する。**そのため、初期化ブロックはコンストラクタが実行されるまえに実行される。**
    - staticイニシャライザはstaticなフィールドにアクセスした際に実行される
15. ○
16. ○　オーバーロードされたコンストラクタから他のコンストラクタを呼び出す。
    #### ■ point
    - コンストラクタ内から、オーバーロードされた他のコンストラクタを呼び出すにはthisを使う
17. ☓　
     #### ■ point
     - thisを使って、コンストラクタ内から、オーバーロードされたコンストラクタを呼び出す際は、コンストラクタ呼び出しのコードよりも前に処理は何も記述出来ない。  
      記述する場合はコンパイルエラーが発生
18. ○　他のパッケージに属するクラスからフィールドへのアクセス制御
    #### ■ point
    - public --全てのクラスからアクセス可能
    - protected -- 同じパッケージに属するか、継承しているサブクラスからのみアクセス可能
    - なし  -- 同じパッケージに属するクラスからのみアクセス可能
    - private -- クラス内からのみアクセス可能

19. ☓  

| アクセスの修飾子 | 可視性 |
| ---- | ---- |
| public | + |
| protected | # |
| なし | - |
| private | ~ |

|  TH  |  TH  |
| ---- | ---- |
|  TD  |  TD  |
|  TD  |  TD  |



20. 
21. 
22. 

## 第七章　継承の操作  
@override -- @Override を記述することで、スペルミスや存在しないメソッドをオーバーライドしているという問題がすぐに明らかになる。



1. ○
2. ○　継承では何を引き継ぐか
     #### ■ point 
     - 継承をすることで、サブクラスはスーパークラスの特徴を引き継ぎますが、スーパークラスの全てを引き継ぐわけでなはい。
     - 継承をしていても次の２つは引き継げない
        1. コンストラクタ
        2. privateなフィールドやメソッド

3. △ インターフェースの基礎知識
    #### ■ point
     - インターフェースは、クラスから「型」だけを取り出したもの
     - 型とはそのものの扱い方を決めるもの
     - interfaceはコンパイラによって自動的にpublicで装飾される(protectedやprivateで装飾することはできない)
     -　クラスの多重継承は禁止されているが、インターフェースの多重実現は認められている

        ```java
        public class ConcreteClass implements InterfaceA, InterfaceB{
          //any code
        }
        複数のインターフェースを実現する場合は、上記コードのようにカンマ区切りで列挙する。

        ```
     - インターフェースには、実現クラスがもつべき抽象メソッドを宣言する。抽象メソッドの中身(実装)をもつことはできない。

        ```java
        public interface Sample{
          public void hello(){}//コンパイルエラー
           public void hello()// ok
        }

        中カッコ「{}」だけを記述して処理を記述しないというものもあるが、これは「処理なし」という中身を持っているものと解釈される。
        ```
     - インターフェースには、動的に値が変わるフィールドも記述できない。ただし、次の２つを満たすフィールドであれば記述できる。*フィールドとは、クラスに直接宣言された変数のこと
        1. finalを使って、動的に値が変更されないこと(定数)
        2. staticを使って、インスタンスが生成されなくても使えること。  
          
     - インターフェースにおいても、あるインターフェースを拡張した新しいインターフェースを定義できる

      ```java
      public interface SubInterface extends SuperInterface{
        // any definition
      }
      ```

4. 抽象クラスの基礎知識  
    #### ■ point
    - 抽象クラスとは、インターフェースとクラスの両方の性質を持ったクラス。
      つまり、実装をもつ具象メソッドと、実装を持たない抽象メソッドの両方をもつことができる。
    - 抽象クラスに定義した具象メソッドは、その抽象クラスを継承したサブクラスが引き継ぐ
      また、抽象メソッドはそのサブクラスでオーバーライドして実装し直さなければabstractを外すことができない。
    - インターフェースはメソッドの実装を持たないため、インスタンス化ができない。
    - インターフェースの特性（抽象メソッド）を持った抽象クラスもインターフェース同様にインスタンス化できない。
    - 抽象クラスの継承は具象クラスだけではなく抽象クラスでも可能
    - インターフェースには、定数フィールド、staticフィールドしか定義出来ないが、抽象クラスにはフィールドが定義できる。

5. 
6. 
7. 
8. 
9. 
10. 
11. 
12. 
13. 
14. 
15. 
16. 
17. 

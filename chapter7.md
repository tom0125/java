## 第七章　継承の操作  
@override -- @Override を記述することで、スペルミスや存在しないメソッドをオーバーライドしているという問題がすぐに明らかになる。

クラスに1つもコンストラクタが定義されていない場合に限り、引数なし、処理なしのコンストラクタが自動で定義される。
```java
public class Hello {
    public Hello() {//デフォルトコンストラクタのアクセス修飾子はpublic
    }
    ...
}
```



1. ○
2. ○　継承では何を引き継ぐか
     #### ■ point 
     - 継承をすることで、サブクラスはスーパークラスの特徴を引き継ぎますが、スーパークラスの全てを引き継ぐわけでなはい。
     - 継承をしていても次の２つは引き継げない
        1. コンストラクタ
        2. privateなフィールドやメソッド

3. △ インターフェースの基礎知識
    #### ■ point
     - インターフェースは、クラスから「型」だけを取り出したもの
     - 型とはそのものの扱い方を決めるもの
     - interfaceはコンパイラによって自動的にpublicで装飾される(protectedやprivateで装飾することはできない)
     -　クラスの多重継承は禁止されているが、インターフェースの多重実現は認められている

        ```java
        public class ConcreteClass implements InterfaceA, InterfaceB{
          //any code
        }
        複数のインターフェースを実現する場合は、上記コードのようにカンマ区切りで列挙する。

        ```
     - インターフェースには、実現クラスがもつべき抽象メソッドを宣言する。抽象メソッドの中身(実装)をもつことはできない。

        ```java
        public interface Sample{
          public void hello(){}//コンパイルエラー
           public void hello()// ok
        }

        中カッコ「{}」だけを記述して処理を記述しないというものもあるが、これは「処理なし」という中身を持っているものと解釈される。
        ```
     - インターフェースには、動的に値が変わるフィールドも記述できない。ただし、次の２つを満たすフィールドであれば記述できる。*フィールドとは、クラスに直接宣言された変数のこと
        1. finalを使って、動的に値が変更されないこと(定数)
        2. staticを使って、インスタンスが生成されなくても使えること。  
          
     - インターフェースにおいても、あるインターフェースを拡張した新しいインターフェースを定義できる

      ```java
      public interface SubInterface extends SuperInterface{
        // any definition
      }
      ```

4. △ 抽象クラスの基礎知識  
    #### ■ point
    - 抽象クラスとは、インターフェースとクラスの両方の性質を持ったクラス。
      つまり、実装をもつ具象メソッドと、実装を持たない抽象メソッドの両方をもつことができる。
    - 抽象クラスに定義した具象メソッドは、その抽象クラスを継承したサブクラスが引き継ぐ
      また、抽象メソッドはそのサブクラスでオーバーライドして実装し直さなければabstractを外すことができない。
    - インターフェースはメソッドの実装を持たないため、インスタンス化ができない。
    - インターフェースの特性（抽象メソッド）を持った抽象クラスもインターフェース同様にインスタンス化できない。
    - 抽象クラスの継承は具象クラスだけではなく抽象クラスでも可能
    - インターフェースには、定数フィールド、staticフィールドしか定義出来ないが、**抽象クラスにはフィールドが定義できる。**

5. △
6. △
  #### ■ point 
  オーバーライドとは
  - 親クラス（スーパークラス）で定義されているインスタンスメソッドを、子クラス（サブクラス）で再定義すること。
  - 親クラス（スーパークラス）のメソッドを変更することは出来ませんが、子クラス（サブクラス）に特化した機能を付与する事は可能です。
  - アクセス修飾子が「private」以外でオーバーライドは適用対象となります。（例：「public」・「protected」）
  - オーバーライドする側はオーバーライドされる側と「メソッド名」、「引数型」、「引数の数」シグニチャが全て一致する必要がある。
    どれか一つでも異なる場合はオーバーラ イドとは見做されない。戻り値は同じ型であることが基本だが、java SE 5から**共変戻り値**が導入され、
    **同じ型かそのサブクラスであればオーバーライドしたメソッドの戻り値型に指定できる。**
  - アクセス修飾子が同じかより緩いもの

  オーバーロードとは
  -　同じメソッド名で複数のメソッドを定義するには、引数の数が異なっているか、引数のデータ型が異なっている必要がある。
  -  戻り値だけが異なっている場合、アクセス修飾子だけ異なっている場合はオーバーロード不可。引数の数、データ型が異なっている必要がある。


7. ○　 オーバーライド　アクセス修飾子
8. 継承関係にある２つのクラスで同名のフィールドが使われているとき、どちらが優先されるか
    #### ■ point
    - フィールドを参照した場合には、変数の型で宣言されたほうを使う
    - メソッドを呼び出した際にはメソッド内の指示に従う
    - Aクラスに定義されているメソッドは、Aクラスに定義されているフィールドを使う。
    - Bクラスでオーバーライドしていた場合は、Bクラスに定義されているフィールドを使う。
    - ポリモーフィズムを使った場合、スーパークラスとサブクラスに同じ名前のフィールドがあったとき、どちらのフィールドを利用するかは、宣言した変数の型によって決まる。

9. ○△
10. ○△
    #### ■ point
    - A型で扱っているインスタンスはA型に定義されているメソッドや、フィールドしか使えない。
    - ポリモーフィズムを使った出題の場合
      1. 継承関係や実現関係がありポリモーフィズムが成り立つ条件を備えているか
      1. インスタンスを扱っている型に、呼び出しているメソッドが定義されているかどうか
    - フィールドやメソッドの呼び出しは、変数で定義されたものしか使えない。ポリモーフィズムを使った問題では、変数が何型か確認。
    
11. ○　ポリモーフィズムが成り立つかどうか
12. ○　ダウンキャスト、アップキャスト
13. ○
14. ○△　フィールドへのアクセス方法
     #### ■ point
     - フィールドとローカル変数を同じ名前で宣言した場合、ローカル変数が優先される。
     - ローカル変数ではなく、フィールドを使いたい場合にはthisを使う。その場合の書式は「this.フィールド名」

15. ☓　
    #### ■ point
    - thisはインスタンス自身の参照を持っている。
    - サブクラスのインスタンスは、スーパークラスのインスタンスと差分のインスタンスの両方で構成されている。
    - thisを使った場合どちらのインスタンスを示すかに注意。

16. ○ 
17. ○

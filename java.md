## 第三章

3.
  char 16ビットUnicode文字 ¥u0000～¥uFFFF
  byte:-128~127 short:-32768~32767
  データ型	値
  boolean	true or false  
  char	16ビットUnicode文字 ¥u0000～¥uFFFF  
  byte	8ビット整数 -128～127  
  short	16ビット整数 -32768～32767  
  int	32ビット整数 -2147483648～2147483647  
  long	64ビット整数 -9223372036854775808～9223372036854775807  
  float	32ビット単精度浮動小数点数 末尾にｆ 
  double	64ビット倍精度浮動小数点数  

4.

5.

6.ショートサーキット演算子　%% || 左オペランドの結果によって、右オペランドの評価を行わない

7.

8.同一性と同値性  
	同じインスタンスであること　同一　　同じインスタンスを参照していること　==演算子で判定  
	同じ値であること　同値  

9.参照の先にあるインスタンスが同じ値を持っているかはequalsメソッドで確認  
	objectクラスに定義されているewualsメソッドは同一性を確認する実装になっている  

```java :title

	public boolean equals(Object obj){
		return(this == obj)
	}

	//そのため同値であることの条件を定め、equalsメソッドをオーバーライドすることで実装する

	public boolean equals(Object obj{
		if(obj == null) {
			return false;
		}
		if(obj instanceof Sample) {
			Sample s = (Sample)obj;
			return s.num == this.num;
		}
		return false;
		}
```
10.equalsメソッドをオーバーライドする場合、メソッドのシグニチャを変更してはいけない 

11.equalsメソッドをオーバーライドする場合いくつか条件があるが、試験対策としては 
     null以外の参照値xについてはx.equals(null)はfalseを返すこと　を抑えておく 

12.コンスタントプール

13.コンスタントプールは文字リテラルを使ったときだけ有効

14.

15.中カッコがない問題は中カッコがあるコードに書き直すべし

16.

17.
18.
*switch文の条件式が戻せる型　switch(条件式)  
  *int型以下の整数型とそのラッパークラス  
  *文字と文字列  
  *列挙型  
  *long,double,float,boolean は不可
*case値
  *条件式が戻す値と同じ型か互換性がある型であること
  *定数であるか、コンパイル時に値を決めることができること
  *nullでないこと
	
20.breakがない場合、その後のすべてのcase式の処理が実行される。その場合はdefault式も対象
21.三項演算子　　真偽値式　？ trueの場合に評価する式 : falseの場合に評価する式　
22.ネストした３項演算子

## 第四章　配列の作成と使用

1.

2. ○  
  配列型変数の参照方法　int[] a, int []a,int[]a []このように複数の表し方がある　
3. ○  
  配列型変数を指定する際には、要素数を指定することはできない int a[3]→☓
4. 多次元配列  
```java 
  //配列インスタンスの生成には要素数を指定しなければならない   
	//要素数の指定は整数値で記述しなければならない  
	int [] [] array = new int [3][];  
	array[0] = new int[3];  
	array[1] = new int[3];
	array[2] = new int[3];  
	//このように、一次元目と二次元目を別々のタイミングで生成することも可能  
	//このとき、一次元目の要素数は省略できないことに注意 
```
5. ☓　
  - 配列インスタンスを生成した直後は、要素はデフォルト値で初期化されている。  
	- 整数型 0
	- 浮動小数点数型 0.0
	- 真偽値 false
	- 文字型 ¥u0000
	- オブジェクト型 null
6. ○  
  配列インスタンスと要素の値は異なることを理解。要素の値が変わっても配列そのものが影響を受けることはない。
7. ☓  
```java :title
  int[][]array = {{2,3},{4,5}};  
  int[][]array = new int[] {}; //変数が二次元、参照先の配列インスタンスは一次元であるため、コンパイルエラー  
  int[][]array = new int[][] {};//次元数を一致させた場合コンパイルエラーは発生しない.  
  int[][]array = {};//初期化演算子が自動的に必要な次元数を算出して必要な初期化を行うためコンパイルエラーは発生しない.  

  new演算子と初期化演算子の両方を使って配列のインスタンスを生成と初期化を同時に行う場合要素数は自動算出されるため、大カッコの中に要素数は指定できない  

  int[][] array = new int[3][] {};
```

  初期化演算子を使って、配列のインスタンス生成と初期化を同時に行う場合、変数の宣言と参照の代入も同時に行う。

  そのため、セミコロンを使って変数宣言と配列インスタンスの生成のタイミングを分けることはできない.

  int[]array ;array = {2,3};//初期化演算子は、変数の次元数と同じ次元数で配列を作るようにしているため、変数宣言と同時にしか使えない。

  int[][]array;array = new int[][] {};//大かっこを使ってプログラマーが明示的に次元数を記述すれば、コンパイルエラーは発生しない。

8.○　多次元配列では、二次元目以降の配列の要素数を揃える必要がない。
  int[][] array  ={{1,2},null,{3,4,5},{6,7,8}}
  このように、４つの要素を持つ一次元目の配列が、２つ、３つ、４つとバラバラの要素数を持つ配列への参照を持つことも可能
  このような配列のことを「非対称な多次元配列」とよぶ。
 
9.
  public interface A {}
  public abstract class B implements A {}
  public class C extends B {}
  public class D extends C {}
  public class Main{
    public static void main[String[]args]{
      A[]array  = {new C(),null,new D()};
      Object[] objectArray = array;
    }
  }

  あるクラスの継承関係にあるとき、スーパークラス型の配列型変数で、サブクラスのインスタンスの集合を扱える。
  Object[] obj = {”A”,"B","C"};
  Object型しか扱わない、配列型変数とString型しか扱わない配列インスアタンスは扱う方が異なるが、Stringクラスは、Objectクラスを継承しているため、問題なくコンパイル実行できる

  A[]array = new D[]{ (D) new C(),null ,new D()};
  このような場合明示的にキャスト式を記述しているためコンパイルエラーは発生しないが、実行してみると、CクラスはDに変換できないためClassCastExceptionがスローされる

  ■point
  インターフェースや抽象クラス、スーパークラスを使って配列型変数を宣言した場合、配列インスタンスはインターフェースの実現クラスであったり、
  抽象クラスや具象クラスのサブクラスのインスタンスの集合を扱える.


10.△
  ここでは配列のコピーを行う際の注意点について説明します。Javaではオブジェクトのコピーを行う際、
  シャローコピー(shallowコピー）、ディープコピー（deepコピー）という2つの方式を意識する必要があります。
  シャローコピーとはコピー先のオブジェクトに対し、そのオブジェクトの参照情報のみ複写する方法です。
  つまりコピー元、コピー先とも同じオブジェクトを参照しています。ディープコピーとはコピー先のオブジェクトに対し、
  参照情報だけでなくオブジェクトの実体も複写する方法です。シャローコピーを行った場合は、
  コピー先のオブジェクトの値を変更するとコピー元のオブジェクトの値も変更されます。
  配列もオブジェクトですからシャローコピーとディープコピーを考慮する必要があります。
  cloneメソッド、arraycopyメソッドを使用した場合はシャローコピーとなります。
  forループを使用した場合はループ内の実装方法の違い（新たなインスタンスを生成するか(ディープ）、
  代入演算子=によりコピーを行うか(シャロー)。）によりディープコピーにもなりますし、
  シャローコピーにもなります。どちらの方法を使用するかはケースにより異なります。

  ■point
  配列要素が基本型の場合→ディープコピー
  多次元配列は、一次元目はディープコピー、それ以降はシャローコピーとなる

  配列要素がオブジェクト型の場合のclone()メソッドは配列インスタンスをディープコピーで作成しますが、各配列要素が指し示すオブジェクトはシャロ―コピーで作成します。
  String[]arrayA = {"1","2"};
		String []arrayB = arrayA.clone();
		arrayB[0] = "3";
		System.out.println(arrayA[0]);
		System.out.println(arrayB[0]);

    結果：1 ¥n 3
11.☓　
  System.arraycopy(src, 0, dest, 0, 3);
  第一引数　コピー元となる配列
  第二引数　コピー元のどの位置からコピーを開始するか
  第三引数　コーピー先の配列
  第四引数　コピー先配列のどのイチからコピーを開始するか
  第五引数　第二引数の位置からいくつの要素をコピーするか

  ■point
  Systemクラスのarrayコピーメソッドは配列の一部をコピーしたい際に使う
  array.copyメソッドは第二引数と第四引数は配列のどの位置からコピーするかを指定する番号、最後の引数はコピーする数と覚える

## 第五章　ループ構造の使用
1.○
2.○
3.○
  ■point
  while文やdo-while文では、中括弧を省略した場合、次の文だけが繰り返しの対象になる。
  do-while文で中括弧を省略した場合には、doとwhileの間には一文のみを記述できる。二文以上記述した場合にはコンパイルエラーになる。
  セミコロンが現れるまでが一つの文のため,中カッコを使わないwhile文の中に複数行に渡るdo-while文を記述することは問題ない。

  while(条件文)
    do{
      複数行の処理
      
    }while;
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
